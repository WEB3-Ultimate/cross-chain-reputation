{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TvmException = exports.Contract = void 0;\n\nconst models_1 = require(\"./models\");\n/**\n * @category Contract\n */\n\n\nclass Contract {\n  constructor(provider, abi, address) {\n    if (!Array.isArray(abi.functions)) {\n      throw new Error('Invalid abi. Functions array required');\n    }\n\n    if (!Array.isArray(abi.events)) {\n      throw new Error('Invalid abi. Events array required');\n    }\n\n    this._provider = provider;\n    this._abi = JSON.stringify(abi);\n    this._functions = abi.functions.reduce((functions, item) => {\n      functions[item.name] = {\n        inputs: item.inputs || [],\n        outputs: item.outputs || []\n      };\n      return functions;\n    }, {});\n    this._events = abi.events.reduce((events, item) => {\n      events[item.name] = {\n        inputs: item.inputs || []\n      };\n      return events;\n    }, {});\n    this._address = address;\n\n    class ContractMethodImpl {\n      constructor(provider, functionAbi, abi, address, method, params) {\n        this.provider = provider;\n        this.functionAbi = functionAbi;\n        this.abi = abi;\n        this.address = address;\n        this.method = method;\n        this.params = (0, models_1.serializeTokensObject)(params);\n      }\n\n      async send(args) {\n        await this.provider.ensureInitialized();\n        const {\n          transaction\n        } = await this.provider.rawApi.sendMessage({\n          sender: args.from.toString(),\n          recipient: this.address.toString(),\n          amount: args.amount,\n          bounce: args.bounce == null ? true : args.bounce,\n          payload: {\n            abi: this.abi,\n            method: this.method,\n            params: this.params\n          }\n        });\n        return (0, models_1.parseTransaction)(transaction);\n      }\n\n      async sendWithResult(args) {\n        await this.provider.ensureInitialized();\n        let subscriber = args.subscriber;\n        const hasTempSubscriber = subscriber == null;\n\n        if (subscriber == null) {\n          subscriber = new this.provider.Subscriber();\n        }\n\n        try {\n          // Parent transaction from wallet\n          let parentTransaction; // Child transaction promise\n\n          let resolveChildTransactionPromise;\n          const childTransactionPromise = new Promise(resolve => {\n            resolveChildTransactionPromise = tx => resolve(tx);\n          }); // Array for collecting transactions on target before parent transaction promise resolution\n\n          const possibleChildren = []; // Subscribe to this account\n\n          subscriber.transactions(this.address).flatMap(batch => batch.transactions) // Listen only messages from sender\n          .filter(item => {\n            var _a;\n\n            return ((_a = item.inMessage.src) === null || _a === void 0 ? void 0 : _a.equals(args.from)) || false;\n          }).on(tx => {\n            if (parentTransaction == null) {\n              // If we don't known whether the message was sent just collect all transactions from the sender\n              possibleChildren.push(tx);\n            } else if (parentTransaction.possibleMessages.findIndex(msg => msg.hash == tx.inMessage.hash) >= 0) {\n              // Resolve promise if transaction was found\n              resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(tx);\n            }\n          }); // Send message\n\n          const transaction = await this.send(args); // Extract all outgoing messages from the parent transaction to this contract\n\n          const possibleMessages = transaction.outMessages.filter(msg => {\n            var _a;\n\n            return ((_a = msg.dst) === null || _a === void 0 ? void 0 : _a.equals(this.address)) || false;\n          }); // Update stream state\n\n          parentTransaction = {\n            transaction,\n            possibleMessages\n          }; // Check whether child transaction was already found\n\n          const alreadyReceived = possibleChildren.find(tx => {\n            return possibleMessages.findIndex(msg => msg.hash == tx.inMessage.hash) >= 0;\n          });\n\n          if (alreadyReceived != null) {\n            resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(alreadyReceived);\n          }\n\n          const childTransaction = await childTransactionPromise; // Parse output\n\n          let output = undefined;\n\n          try {\n            const result = await this.provider.rawApi.decodeTransaction({\n              transaction: (0, models_1.serializeTransaction)(childTransaction),\n              abi: this.abi,\n              method: this.method\n            });\n\n            if (result != null) {\n              output = this.functionAbi.outputs != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, result.output) : {};\n            }\n          } catch (e) {\n            console.error(e);\n          } // Done\n\n\n          return {\n            parentTransaction: parentTransaction.transaction,\n            childTransaction,\n            output\n          };\n        } finally {\n          hasTempSubscriber && (await subscriber.unsubscribe());\n        }\n      }\n\n      async estimateFees(args) {\n        await this.provider.ensureInitialized();\n        const {\n          fees\n        } = await this.provider.rawApi.estimateFees({\n          sender: args.from.toString(),\n          recipient: this.address.toString(),\n          amount: args.amount,\n          payload: {\n            abi: this.abi,\n            method: this.method,\n            params: this.params\n          }\n        });\n        return fees;\n      }\n\n      async sendExternal(args) {\n        await this.provider.ensureInitialized();\n        let method = args.withoutSignature === true ? this.provider.rawApi.sendUnsignedExternalMessage : this.provider.rawApi.sendExternalMessage;\n        let {\n          transaction,\n          output\n        } = await method({\n          publicKey: args.publicKey,\n          recipient: this.address.toString(),\n          stateInit: args.stateInit,\n          payload: {\n            abi: this.abi,\n            method: this.method,\n            params: this.params\n          },\n          local: args.local\n        });\n        return {\n          transaction: (0, models_1.parseTransaction)(transaction),\n          output: output != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined\n        };\n      }\n\n      async call() {\n        let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        await this.provider.ensureInitialized();\n        let {\n          output,\n          code\n        } = await this.provider.rawApi.runLocal({\n          address: this.address.toString(),\n          cachedState: args.cachedState,\n          responsible: args.responsible,\n          functionCall: {\n            abi: this.abi,\n            method: this.method,\n            params: this.params\n          }\n        });\n\n        if (output == null || code != 0) {\n          throw new TvmException(code);\n        } else {\n          return (0, models_1.parseTokensObject)(this.functionAbi.outputs, output);\n        }\n      }\n\n      async encodeInternal() {\n        await this.provider.ensureInitialized();\n        let {\n          boc\n        } = await this.provider.rawApi.encodeInternalInput({\n          abi: this.abi,\n          method: this.method,\n          params: this.params\n        });\n        return boc;\n      }\n\n    }\n\n    this._methods = new Proxy({}, {\n      get: (_object, method) => {\n        const rawAbi = this._functions[method];\n        return params => new ContractMethodImpl(this._provider, rawAbi, this._abi, this._address, method, params);\n      }\n    });\n  }\n\n  get methods() {\n    return this._methods;\n  }\n\n  get address() {\n    return this._address;\n  }\n\n  get abi() {\n    return this._abi;\n  }\n\n  async waitForEvent() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      range,\n      filter\n    } = args;\n    let subscriber = args.subscriber;\n    const hasTempSubscriber = subscriber == null;\n\n    if (subscriber == null) {\n      subscriber = new this._provider.Subscriber();\n    }\n\n    const event = await ((range === null || range === void 0 ? void 0 : range.fromLt) != null || (range === null || range === void 0 ? void 0 : range.fromUtime) != null ? subscriber.oldTransactions(this._address, range).merge(subscriber.transactions(this._address)) : subscriber.transactions(this.address)).flatMap(item => item.transactions).takeWhile(item => range == null || (range.fromLt == null || item.id.lt > range.fromLt) && (range.fromUtime == null || item.createdAt > range.fromUtime) && (range.toLt == null || item.id.lt < range.toLt) && (range.toUtime == null || item.createdAt < range.toUtime)).flatMap(tx => this.decodeTransactionEvents({\n      transaction: tx\n    }).then(events => {\n      events.forEach(event => event.transaction = tx);\n      return events;\n    })).filterMap(async event => {\n      if (filter == null || (await filter(event))) {\n        return event;\n      } else {\n        return undefined;\n      }\n    }).first();\n    hasTempSubscriber && (await subscriber.unsubscribe());\n    return event;\n  }\n\n  async getPastEvents(args) {\n    const {\n      range,\n      filter,\n      limit\n    } = args;\n    let result = [];\n    let currentContinuation = args === null || args === void 0 ? void 0 : args.continuation;\n\n    outer: while (true) {\n      const {\n        transactions,\n        continuation\n      } = await this._provider.getTransactions({\n        address: this._address,\n        continuation: currentContinuation\n      });\n\n      if (transactions.length === null) {\n        break;\n      }\n\n      const filteredTransactions = transactions.filter(item => ((range === null || range === void 0 ? void 0 : range.fromLt) == null || item.id.lt > range.fromLt) && ((range === null || range === void 0 ? void 0 : range.fromUtime) == null || item.createdAt > range.fromUtime) && ((range === null || range === void 0 ? void 0 : range.toLt) == null || item.id.lt < (range === null || range === void 0 ? void 0 : range.toLt)) && ((range === null || range === void 0 ? void 0 : range.toUtime) == null || item.createdAt < (range === null || range === void 0 ? void 0 : range.toUtime)));\n\n      if (filteredTransactions.length > 0) {\n        const parsedEvents = await Promise.all(filteredTransactions.map(async tx => {\n          return {\n            tx,\n            events: await this.decodeTransactionEvents({\n              transaction: tx\n            }).then(events => {\n              events.forEach(event => event.transaction = tx);\n              return events;\n            })\n          };\n        }));\n\n        for (let {\n          tx,\n          events\n        } of parsedEvents) {\n          if (filter != null) {\n            events = await Promise.all(events.map(async event => (await filter(event)) ? event : undefined)).then(events => events.filter(event => event != null));\n          }\n\n          currentContinuation = tx.id; // update continuation in case of early break\n\n          for (const event of events) {\n            if (limit != null && result.length >= limit) {\n              break outer;\n            }\n\n            result.push(event);\n          }\n\n          if (limit != null && result.length >= limit) {\n            break outer;\n          }\n        }\n      }\n\n      currentContinuation = continuation;\n\n      if (currentContinuation == null) {\n        break;\n      }\n    }\n\n    return {\n      events: result,\n      continuation: currentContinuation\n    };\n  }\n\n  async decodeTransaction(args) {\n    await this._provider.ensureInitialized();\n\n    try {\n      const result = await this._provider.rawApi.decodeTransaction({\n        transaction: (0, models_1.serializeTransaction)(args.transaction),\n        abi: this._abi,\n        method: args.methods\n      });\n\n      if (result == null) {\n        return undefined;\n      }\n\n      let {\n        method,\n        input,\n        output\n      } = result;\n      const rawAbi = this._functions[method];\n      return {\n        method,\n        input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n        output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {}\n      };\n    } catch (_) {\n      return undefined;\n    }\n  }\n\n  async decodeTransactionEvents(args) {\n    await this._provider.ensureInitialized();\n\n    try {\n      const {\n        events\n      } = await this._provider.rawApi.decodeTransactionEvents({\n        transaction: (0, models_1.serializeTransaction)(args.transaction),\n        abi: this._abi\n      });\n      const result = [];\n\n      for (const {\n        event,\n        data\n      } of events) {\n        const rawAbi = this._events[event];\n        result.push({\n          event,\n          data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {}\n        });\n      }\n\n      return result;\n    } catch (_) {\n      return [];\n    }\n  }\n\n  async decodeInputMessage(args) {\n    await this._provider.ensureInitialized();\n\n    try {\n      const result = await this._provider.rawApi.decodeInput({\n        abi: this._abi,\n        body: args.body,\n        internal: args.internal,\n        method: args.methods\n      });\n\n      if (result == null) {\n        return undefined;\n      }\n\n      let {\n        method,\n        input\n      } = result;\n      const rawAbi = this._functions[method];\n      return {\n        method,\n        input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {}\n      };\n    } catch (_) {\n      return undefined;\n    }\n  }\n\n  async decodeOutputMessage(args) {\n    await this._provider.ensureInitialized();\n\n    try {\n      const result = await this._provider.rawApi.decodeOutput({\n        abi: this._abi,\n        body: args.body,\n        method: args.methods\n      });\n\n      if (result == null) {\n        return undefined;\n      }\n\n      let {\n        method,\n        output\n      } = result;\n      const rawAbi = this._functions[method];\n      return {\n        method,\n        output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {}\n      };\n    } catch (_) {\n      return undefined;\n    }\n  }\n\n  async decodeEvent(args) {\n    await this._provider.ensureInitialized();\n\n    try {\n      const result = await this._provider.rawApi.decodeEvent({\n        abi: this.abi,\n        body: args.body,\n        event: args.events\n      });\n\n      if (result == null) {\n        return undefined;\n      }\n\n      let {\n        event,\n        data\n      } = result;\n      const rawAbi = this._events[event];\n      return {\n        event,\n        data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {}\n      };\n    } catch (_) {\n      return undefined;\n    }\n  }\n\n}\n\nexports.Contract = Contract;\n/**\n * @category Contract\n */\n\nclass TvmException extends Error {\n  constructor(code) {\n    super(`TvmException: ${code}`);\n    this.code = code;\n  }\n\n}\n\nexports.TvmException = TvmException;","map":{"version":3,"names":["Object","defineProperty","exports","value","TvmException","Contract","models_1","require","constructor","provider","abi","address","Array","isArray","functions","Error","events","_provider","_abi","JSON","stringify","_functions","reduce","item","name","inputs","outputs","_events","_address","ContractMethodImpl","functionAbi","method","params","serializeTokensObject","send","args","ensureInitialized","transaction","rawApi","sendMessage","sender","from","toString","recipient","amount","bounce","payload","parseTransaction","sendWithResult","subscriber","hasTempSubscriber","Subscriber","parentTransaction","resolveChildTransactionPromise","childTransactionPromise","Promise","resolve","tx","possibleChildren","transactions","flatMap","batch","filter","_a","inMessage","src","equals","on","push","possibleMessages","findIndex","msg","hash","outMessages","dst","alreadyReceived","find","childTransaction","output","undefined","result","decodeTransaction","serializeTransaction","parseTokensObject","e","console","error","unsubscribe","estimateFees","fees","sendExternal","withoutSignature","sendUnsignedExternalMessage","sendExternalMessage","publicKey","stateInit","local","call","code","runLocal","cachedState","responsible","functionCall","encodeInternal","boc","encodeInternalInput","_methods","Proxy","get","_object","rawAbi","methods","waitForEvent","range","event","fromLt","fromUtime","oldTransactions","merge","takeWhile","id","lt","createdAt","toLt","toUtime","decodeTransactionEvents","then","forEach","filterMap","first","getPastEvents","limit","currentContinuation","continuation","outer","getTransactions","length","filteredTransactions","parsedEvents","all","map","input","_","data","decodeInputMessage","decodeInput","body","internal","decodeOutputMessage","decodeOutput","decodeEvent"],"sources":["/Users/romanrakhlin/Dropbox/Mac/Desktop/cross-chain-reputation/client/node_modules/everscale-inpage-provider/dist/contract.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TvmException = exports.Contract = void 0;\nconst models_1 = require(\"./models\");\n/**\n * @category Contract\n */\nclass Contract {\n    constructor(provider, abi, address) {\n        if (!Array.isArray(abi.functions)) {\n            throw new Error('Invalid abi. Functions array required');\n        }\n        if (!Array.isArray(abi.events)) {\n            throw new Error('Invalid abi. Events array required');\n        }\n        this._provider = provider;\n        this._abi = JSON.stringify(abi);\n        this._functions = abi.functions.reduce((functions, item) => {\n            functions[item.name] = { inputs: item.inputs || [], outputs: item.outputs || [] };\n            return functions;\n        }, {});\n        this._events = abi.events.reduce((events, item) => {\n            events[item.name] = { inputs: item.inputs || [] };\n            return events;\n        }, {});\n        this._address = address;\n        class ContractMethodImpl {\n            constructor(provider, functionAbi, abi, address, method, params) {\n                this.provider = provider;\n                this.functionAbi = functionAbi;\n                this.abi = abi;\n                this.address = address;\n                this.method = method;\n                this.params = (0, models_1.serializeTokensObject)(params);\n            }\n            async send(args) {\n                await this.provider.ensureInitialized();\n                const { transaction } = await this.provider.rawApi.sendMessage({\n                    sender: args.from.toString(),\n                    recipient: this.address.toString(),\n                    amount: args.amount,\n                    bounce: args.bounce == null ? true : args.bounce,\n                    payload: {\n                        abi: this.abi,\n                        method: this.method,\n                        params: this.params,\n                    },\n                });\n                return (0, models_1.parseTransaction)(transaction);\n            }\n            async sendWithResult(args) {\n                await this.provider.ensureInitialized();\n                let subscriber = args.subscriber;\n                const hasTempSubscriber = subscriber == null;\n                if (subscriber == null) {\n                    subscriber = new this.provider.Subscriber();\n                }\n                try {\n                    // Parent transaction from wallet\n                    let parentTransaction;\n                    // Child transaction promise\n                    let resolveChildTransactionPromise;\n                    const childTransactionPromise = new Promise((resolve) => {\n                        resolveChildTransactionPromise = (tx) => resolve(tx);\n                    });\n                    // Array for collecting transactions on target before parent transaction promise resolution\n                    const possibleChildren = [];\n                    // Subscribe to this account\n                    subscriber.transactions(this.address)\n                        .flatMap(batch => batch.transactions)\n                        // Listen only messages from sender\n                        .filter(item => { var _a; return ((_a = item.inMessage.src) === null || _a === void 0 ? void 0 : _a.equals(args.from)) || false; })\n                        .on((tx) => {\n                        if (parentTransaction == null) {\n                            // If we don't known whether the message was sent just collect all transactions from the sender\n                            possibleChildren.push(tx);\n                        }\n                        else if (parentTransaction.possibleMessages.findIndex((msg) => msg.hash == tx.inMessage.hash) >= 0) {\n                            // Resolve promise if transaction was found\n                            resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(tx);\n                        }\n                    });\n                    // Send message\n                    const transaction = await this.send(args);\n                    // Extract all outgoing messages from the parent transaction to this contract\n                    const possibleMessages = transaction.outMessages.filter(msg => { var _a; return ((_a = msg.dst) === null || _a === void 0 ? void 0 : _a.equals(this.address)) || false; });\n                    // Update stream state\n                    parentTransaction = {\n                        transaction,\n                        possibleMessages,\n                    };\n                    // Check whether child transaction was already found\n                    const alreadyReceived = possibleChildren.find((tx) => {\n                        return possibleMessages.findIndex((msg) => msg.hash == tx.inMessage.hash) >= 0;\n                    });\n                    if (alreadyReceived != null) {\n                        resolveChildTransactionPromise === null || resolveChildTransactionPromise === void 0 ? void 0 : resolveChildTransactionPromise(alreadyReceived);\n                    }\n                    const childTransaction = await childTransactionPromise;\n                    // Parse output\n                    let output = undefined;\n                    try {\n                        const result = await this.provider.rawApi.decodeTransaction({\n                            transaction: (0, models_1.serializeTransaction)(childTransaction),\n                            abi: this.abi,\n                            method: this.method,\n                        });\n                        if (result != null) {\n                            output = this.functionAbi.outputs != null\n                                ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, result.output)\n                                : {};\n                        }\n                    }\n                    catch (e) {\n                        console.error(e);\n                    }\n                    // Done\n                    return {\n                        parentTransaction: parentTransaction.transaction,\n                        childTransaction,\n                        output,\n                    };\n                }\n                finally {\n                    hasTempSubscriber && (await subscriber.unsubscribe());\n                }\n            }\n            async estimateFees(args) {\n                await this.provider.ensureInitialized();\n                const { fees } = await this.provider.rawApi.estimateFees({\n                    sender: args.from.toString(),\n                    recipient: this.address.toString(),\n                    amount: args.amount,\n                    payload: {\n                        abi: this.abi,\n                        method: this.method,\n                        params: this.params,\n                    },\n                });\n                return fees;\n            }\n            async sendExternal(args) {\n                await this.provider.ensureInitialized();\n                let method = args.withoutSignature === true\n                    ? this.provider.rawApi.sendUnsignedExternalMessage\n                    : this.provider.rawApi.sendExternalMessage;\n                let { transaction, output } = await method({\n                    publicKey: args.publicKey,\n                    recipient: this.address.toString(),\n                    stateInit: args.stateInit,\n                    payload: {\n                        abi: this.abi,\n                        method: this.method,\n                        params: this.params,\n                    },\n                    local: args.local,\n                });\n                return {\n                    transaction: (0, models_1.parseTransaction)(transaction),\n                    output: output != null ? (0, models_1.parseTokensObject)(this.functionAbi.outputs, output) : undefined,\n                };\n            }\n            async call(args = {}) {\n                await this.provider.ensureInitialized();\n                let { output, code } = await this.provider.rawApi.runLocal({\n                    address: this.address.toString(),\n                    cachedState: args.cachedState,\n                    responsible: args.responsible,\n                    functionCall: {\n                        abi: this.abi,\n                        method: this.method,\n                        params: this.params,\n                    },\n                });\n                if (output == null || code != 0) {\n                    throw new TvmException(code);\n                }\n                else {\n                    return (0, models_1.parseTokensObject)(this.functionAbi.outputs, output);\n                }\n            }\n            async encodeInternal() {\n                await this.provider.ensureInitialized();\n                let { boc } = await this.provider.rawApi.encodeInternalInput({\n                    abi: this.abi,\n                    method: this.method,\n                    params: this.params,\n                });\n                return boc;\n            }\n        }\n        this._methods = new Proxy({}, {\n            get: (_object, method) => {\n                const rawAbi = this._functions[method];\n                return (params) => new ContractMethodImpl(this._provider, rawAbi, this._abi, this._address, method, params);\n            },\n        });\n    }\n    get methods() {\n        return this._methods;\n    }\n    get address() {\n        return this._address;\n    }\n    get abi() {\n        return this._abi;\n    }\n    async waitForEvent(args = {}) {\n        const { range, filter } = args;\n        let subscriber = args.subscriber;\n        const hasTempSubscriber = subscriber == null;\n        if (subscriber == null) {\n            subscriber = new this._provider.Subscriber();\n        }\n        const event = await (((range === null || range === void 0 ? void 0 : range.fromLt) != null || (range === null || range === void 0 ? void 0 : range.fromUtime) != null)\n            ? subscriber.oldTransactions(this._address, range)\n                .merge(subscriber.transactions(this._address))\n            : subscriber.transactions(this.address)).flatMap(item => item.transactions)\n            .takeWhile(item => range == null ||\n            (range.fromLt == null || item.id.lt > range.fromLt) &&\n                (range.fromUtime == null || item.createdAt > range.fromUtime) &&\n                (range.toLt == null || item.id.lt < range.toLt) &&\n                (range.toUtime == null || item.createdAt < range.toUtime))\n            .flatMap(tx => this.decodeTransactionEvents({ transaction: tx })\n            .then((events) => {\n            events.forEach((event) => event.transaction = tx);\n            return events;\n        }))\n            .filterMap(async (event) => {\n            if (filter == null || (await filter(event))) {\n                return event;\n            }\n            else {\n                return undefined;\n            }\n        })\n            .first();\n        hasTempSubscriber && (await subscriber.unsubscribe());\n        return event;\n    }\n    async getPastEvents(args) {\n        const { range, filter, limit } = args;\n        let result = [];\n        let currentContinuation = args === null || args === void 0 ? void 0 : args.continuation;\n        outer: while (true) {\n            const { transactions, continuation } = await this._provider.getTransactions({\n                address: this._address,\n                continuation: currentContinuation,\n            });\n            if (transactions.length === null) {\n                break;\n            }\n            const filteredTransactions = transactions.filter((item) => (((range === null || range === void 0 ? void 0 : range.fromLt) == null || item.id.lt > range.fromLt) &&\n                ((range === null || range === void 0 ? void 0 : range.fromUtime) == null || item.createdAt > range.fromUtime) &&\n                ((range === null || range === void 0 ? void 0 : range.toLt) == null || item.id.lt < (range === null || range === void 0 ? void 0 : range.toLt)) &&\n                ((range === null || range === void 0 ? void 0 : range.toUtime) == null || item.createdAt < (range === null || range === void 0 ? void 0 : range.toUtime))));\n            if (filteredTransactions.length > 0) {\n                const parsedEvents = await Promise.all(filteredTransactions.map(async (tx) => {\n                    return {\n                        tx, events: await this.decodeTransactionEvents({ transaction: tx }).then((events) => {\n                            events.forEach((event) => event.transaction = tx);\n                            return events;\n                        }),\n                    };\n                }));\n                for (let { tx, events } of parsedEvents) {\n                    if (filter != null) {\n                        events = await Promise.all(events.map(async (event) => (await filter(event)) ? event : undefined)).then(events => events.filter((event) => event != null));\n                    }\n                    currentContinuation = tx.id; // update continuation in case of early break\n                    for (const event of events) {\n                        if (limit != null && result.length >= limit) {\n                            break outer;\n                        }\n                        result.push(event);\n                    }\n                    if (limit != null && result.length >= limit) {\n                        break outer;\n                    }\n                }\n            }\n            currentContinuation = continuation;\n            if (currentContinuation == null) {\n                break;\n            }\n        }\n        return { events: result, continuation: currentContinuation };\n    }\n    async decodeTransaction(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeTransaction({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            let { method, input, output } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeTransactionEvents(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const { events } = await this._provider.rawApi.decodeTransactionEvents({\n                transaction: (0, models_1.serializeTransaction)(args.transaction),\n                abi: this._abi,\n            });\n            const result = [];\n            for (const { event, data } of events) {\n                const rawAbi = this._events[event];\n                result.push({\n                    event,\n                    data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},\n                });\n            }\n            return result;\n        }\n        catch (_) {\n            return [];\n        }\n    }\n    async decodeInputMessage(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeInput({\n                abi: this._abi,\n                body: args.body,\n                internal: args.internal,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            let { method, input } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                input: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, input) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeOutputMessage(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeOutput({\n                abi: this._abi,\n                body: args.body,\n                method: args.methods,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            let { method, output } = result;\n            const rawAbi = this._functions[method];\n            return {\n                method,\n                output: rawAbi.outputs != null ? (0, models_1.parseTokensObject)(rawAbi.outputs, output) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n    async decodeEvent(args) {\n        await this._provider.ensureInitialized();\n        try {\n            const result = await this._provider.rawApi.decodeEvent({\n                abi: this.abi,\n                body: args.body,\n                event: args.events,\n            });\n            if (result == null) {\n                return undefined;\n            }\n            let { event, data } = result;\n            const rawAbi = this._events[event];\n            return {\n                event,\n                data: rawAbi.inputs != null ? (0, models_1.parseTokensObject)(rawAbi.inputs, data) : {},\n            };\n        }\n        catch (_) {\n            return undefined;\n        }\n    }\n}\nexports.Contract = Contract;\n/**\n * @category Contract\n */\nclass TvmException extends Error {\n    constructor(code) {\n        super(`TvmException: ${code}`);\n        this.code = code;\n    }\n}\nexports.TvmException = TvmException;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}