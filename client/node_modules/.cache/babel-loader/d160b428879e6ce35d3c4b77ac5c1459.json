{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subscriber = void 0;\n\nconst utils_1 = require(\"./utils\");\n/**\n * @category Stream\n */\n\n\nclass Subscriber {\n  constructor(provider) {\n    this.provider = provider;\n    this.subscriptions = {};\n    this.scanners = {};\n\n    this.unsubscribe = async () => this._unsubscribe();\n  }\n  /**\n   * Returns a stream of new transactions\n   */\n\n\n  transactions(address) {\n    return this._addSubscription('transactionsFound', address, false);\n  }\n  /**\n   * Returns a finite stream of child transactions\n   * @param transaction - root transaction\n   */\n\n\n  trace(transaction) {\n    const id = (0, utils_1.getUniqueId)();\n    return new StreamImpl((onData, onEnd) => {\n      const scanner = new TraceTransactionsScanner(this, {\n        origin: transaction,\n        onData,\n        onEnd: eof => {\n          delete this.scanners[id];\n          onEnd(eof);\n        }\n      });\n      this.scanners[id] = scanner;\n      scanner.start(); // Subscription is not required\n\n      return Promise.resolve();\n    }, async () => {\n      const scanner = this.scanners[id];\n      delete this.scanners[id];\n\n      if (scanner != null) {\n        await scanner.stop();\n      }\n    }, identity, true);\n  }\n  /**\n   * Returns a stream of old transactions\n   */\n\n\n  oldTransactions(address, filter) {\n    const id = (0, utils_1.getUniqueId)();\n    return new StreamImpl((onData, onEnd) => {\n      const scanner = new UnorderedTransactionsScanner(this.provider, {\n        address,\n        onData,\n        onEnd: eof => {\n          delete this.scanners[id];\n          onEnd(eof);\n        },\n        ...filter\n      });\n      this.scanners[id] = scanner;\n      scanner.start(); // Subscription is not required\n\n      return Promise.resolve();\n    }, async () => {\n      const scanner = this.scanners[id];\n      delete this.scanners[id];\n\n      if (scanner != null) {\n        await scanner.stop();\n      }\n    }, identity, true);\n  }\n\n  states(address) {\n    return this._addSubscription('contractStateChanged', address, false);\n  }\n\n  async _unsubscribe() {\n    const subscriptions = Object.assign({}, this.subscriptions);\n\n    for (const address of Object.keys(this.subscriptions)) {\n      delete this.subscriptions[address];\n    }\n\n    const scanners = Object.assign({}, this.scanners);\n\n    for (const id of Object.keys(this.scanners)) {\n      delete this.scanners[id];\n    }\n\n    await Promise.all(Object.values(subscriptions).map(async item => {\n      const events = Object.assign({}, item);\n\n      for (const event of Object.keys(events)) {\n        delete item[event];\n      }\n\n      await Promise.all(Object.values(events).map(eventData => {\n        if (eventData == null) {\n          return;\n        }\n\n        return eventData.subscription.then(item => {\n          return item.unsubscribe();\n        }).catch(() => {// ignore\n        });\n      }));\n    }).concat(Object.values(scanners).map(item => item.stop())));\n  }\n\n  _addSubscription(event, address, isFinite) {\n    const rawAddress = address.toString();\n\n    const stopProducer = id => {\n      const subscriptions = this.subscriptions[rawAddress];\n\n      if (subscriptions == null) {\n        // No subscriptions for the address\n        return;\n      }\n\n      const eventData = subscriptions[event];\n\n      if (eventData != null) {\n        const handler = eventData.handlers[id];\n\n        if (handler != null) {\n          // Remove event handler with the id\n          delete eventData.handlers[id];\n          const {\n            queue,\n            onEnd,\n            state\n          } = handler;\n\n          if (!state.finished) {\n            state.finished = true;\n            queue.clear();\n            queue.enqueue(async () => onEnd(state.eof));\n          }\n        } // Remove event data subscription if there are none of them\n\n\n        if (Object.keys(eventData.handlers).length === 0) {\n          const subscription = eventData.subscription;\n          delete subscriptions[event];\n          subscription.then(subscription => subscription.unsubscribe()).catch(console.debug);\n        }\n      } // Remove address subscriptions object if it is empty\n\n\n      if (Object.keys(subscriptions).length === 0) {\n        delete this.subscriptions[rawAddress];\n      }\n    };\n\n    const id = (0, utils_1.getUniqueId)().toString();\n    return new StreamImpl((onData, onEnd) => {\n      let subscriptions = this.subscriptions[rawAddress];\n      let eventData = subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions[event];\n      const state = {\n        eof: false,\n        finished: false\n      }; // Create handler object\n\n      const handler = {\n        onData,\n        onEnd,\n        queue: new PromiseQueue(),\n        state\n      };\n\n      if (eventData != null) {\n        // Add handler if there is already a handler group\n        eventData.handlers[id] = handler;\n        return Promise.resolve();\n      } // Create handlers group\n\n\n      const handlers = {\n        [id]: handler\n      }; // Create subscription\n\n      const subscription = this.provider.subscribe(event, {\n        address\n      }).then(subscription => {\n        subscription.on('data', data => {\n          Object.values(handlers).forEach(_ref => {\n            let {\n              onData,\n              queue,\n              state\n            } = _ref;\n\n            // Skip closed streams\n            if (state.eof || state.finished) {\n              return;\n            }\n\n            queue.enqueue(async () => {\n              if (!(await onData(data))) {\n                state.eof = true;\n                stopProducer(id);\n              }\n            });\n          });\n        });\n        subscription.on('unsubscribed', () => {\n          Object.keys(handlers).forEach(stopProducer);\n        });\n        return subscription;\n      }).catch(e => {\n        console.error(e);\n        Object.keys(handlers).forEach(stopProducer);\n        throw e;\n      }); // Add event data to subscriptions\n\n      eventData = {\n        subscription,\n        handlers\n      };\n\n      if (subscriptions == null) {\n        this.subscriptions[rawAddress] = {\n          [event]: eventData\n        };\n      } else {\n        subscriptions[event] = eventData;\n      } // Wait until subscribed\n\n\n      return subscription.then(() => {});\n    }, () => stopProducer(id), identity, isFinite);\n  }\n\n}\n\nexports.Subscriber = Subscriber;\n\nasync function identity(item, handler) {\n  return handler(item);\n}\n\nclass StreamImpl {\n  constructor(makeProducer, stopProducer, extractor, isFinite) {\n    this.makeProducer = makeProducer;\n    this.stopProducer = stopProducer;\n    this.extractor = extractor;\n    this.isFinite = isFinite;\n    /**\n     * Folds every element into an accumulator by applying an operation, returning the final result\n     */\n\n    this.fold = this.onlyFinite((init, f, ctx) => {\n      let state = init;\n      return new Promise((resolve, reject) => {\n        const subscribed = this.makeProducer( // onData\n        data => this.extractor(data, async item => {\n          state = await f(state, item);\n          return true;\n        }), // onEnd\n        eof => {\n          if (eof) {\n            resolve(state);\n          } else {\n            reject(new Error('Subscription closed'));\n          }\n        });\n\n        if (ctx != null) {\n          ctx.subscribed = subscribed;\n        }\n      });\n    });\n    /**\n     * Waits until the end of the stream\n     */\n\n    this.finished = this.onlyFinite(ctx => {\n      return new Promise((resolve, reject) => {\n        const subscribed = this.makeProducer( // onData\n        data => this.extractor(data, _item => true), // onEnd\n        eof => {\n          if (eof) {\n            resolve(undefined);\n          } else {\n            reject(new Error('Subscription closed'));\n          }\n        });\n\n        if (ctx != null) {\n          ctx.subscribed = subscribed;\n        }\n      });\n    });\n  }\n\n  async delayed(f) {\n    const {\n      subscribed,\n      result\n    } = f({\n      first: () => {\n        const ctx = {};\n        const result = this.first(ctx);\n        return {\n          subscribed: ctx.subscribed,\n          result\n        };\n      },\n      on: handler => {\n        const ctx = {};\n        this.on(handler, ctx);\n        return {\n          subscribed: ctx.subscribed,\n          result: undefined\n        };\n      },\n      fold: this.fold != null ? (init, f) => {\n        const ctx = {};\n        const result = this.fold(init, f, ctx);\n        return {\n          subscribed: ctx.subscribed,\n          result\n        };\n      } : undefined,\n      finished: this.finished != null ? () => {\n        const ctx = {};\n        const result = this.finished(ctx);\n        return {\n          subscribed: ctx.subscribed,\n          result\n        };\n      } : undefined\n    });\n    await subscribed;\n    return () => result;\n  }\n\n  first(ctx) {\n    let state = {\n      found: false\n    };\n    return new Promise((resolve, reject) => {\n      const subscribed = this.makeProducer( // onData\n      data => this.extractor(data, item => {\n        Object.assign(state, {\n          found: true,\n          result: item\n        });\n        return false;\n      }), // onEnd\n      eof => {\n        if (eof) {\n          if (this.isFinite) {\n            resolve(state.found ? state.result : undefined);\n          } else if (state.found) {\n            resolve(state.result);\n          } else {\n            reject(new Error('Unexpected end of stream'));\n          }\n        } else {\n          reject(new Error('Subscription closed'));\n        }\n      });\n\n      if (ctx != null) {\n        ctx.subscribed = subscribed;\n      }\n    });\n  }\n\n  on(handler, ctx) {\n    const subscribed = this.makeProducer(event => this.extractor(event, async item => {\n      await handler(item);\n      return true;\n    }), _eof => {});\n\n    if (ctx != null) {\n      ctx.subscribed = subscribed;\n    }\n  }\n\n  merge(other) {\n    return new StreamImpl((onData, onEnd) => {\n      const state = {\n        stopped: false,\n        counter: 0\n      };\n\n      const checkEnd = eof => {\n        if (state.stopped) {\n          return;\n        }\n\n        if (++state.counter == 2 || !eof) {\n          state.stopped = true;\n          onEnd(eof);\n        }\n      };\n\n      return Promise.all([this.makeProducer(onData, checkEnd), other.makeProducer(onData, checkEnd)]).then(() => {});\n    }, () => {\n      this.stopProducer();\n      other.stopProducer();\n    }, this.extractor, this.isFinite && other.isFinite);\n  }\n\n  enumerate() {\n    const state = {\n      index: 0\n    };\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      return handler({\n        index: state.index++,\n        item\n      });\n    }), this.isFinite);\n  }\n\n  tap(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      await f(item);\n      return handler(item);\n    }), this.isFinite);\n  }\n\n  filter(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      if (await f(item)) {\n        return handler(item);\n      } else {\n        return true;\n      }\n    }), this.isFinite);\n  }\n\n  filterMap(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      const newItem = await f(item);\n\n      if (newItem !== undefined) {\n        return handler(newItem);\n      } else {\n        return true;\n      }\n    }), this.isFinite);\n  }\n\n  map(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      const newItem = await f(item);\n      return handler(newItem);\n    }), this.isFinite);\n  }\n\n  flatMap(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      const items = await f(item);\n\n      for (const newItem of items) {\n        if (!(await handler(newItem))) {\n          return false;\n        }\n      }\n\n      return true;\n    }), this.isFinite);\n  }\n\n  skip(n) {\n    const state = {\n      index: 0\n    };\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, item => {\n      if (state.index >= n) {\n        return handler(item);\n      } else {\n        ++state.index;\n        return true;\n      }\n    }), this.isFinite);\n  }\n\n  skipWhile(f) {\n    const state = {\n      shouldSkip: true\n    };\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      if (!state.shouldSkip || !(await f(item))) {\n        state.shouldSkip = false;\n        return handler(item);\n      } else {\n        return true;\n      }\n    }), this.isFinite);\n  }\n\n  take(n) {\n    const state = {\n      index: 0\n    };\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, item => {\n      if (state.index < n) {\n        ++state.index;\n        return handler(item);\n      } else {\n        return false;\n      }\n    }), true);\n  }\n\n  takeWhile(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      if (await f(item)) {\n        return handler(item);\n      } else {\n        return false;\n      }\n    }), true);\n  }\n\n  takeWhileMap(f) {\n    return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async item => {\n      const newItem = await f(item);\n\n      if (newItem !== undefined) {\n        return handler(newItem);\n      } else {\n        return false;\n      }\n    }), true);\n  }\n\n  onlyFinite(f) {\n    if (this.isFinite) {\n      return f;\n    } else {\n      return undefined;\n    }\n  }\n\n}\n\nclass UnorderedTransactionsScanner {\n  constructor(provider, params) {\n    this.provider = provider;\n    this.params = params;\n    this.queue = new PromiseQueue();\n    this.isRunning = false;\n  }\n\n  start() {\n    if (this.isRunning || this.promise != null) {\n      return;\n    }\n\n    this.isRunning = true;\n\n    this.promise = (async () => {\n      const params = this.params;\n      let state = {\n        complete: false\n      };\n\n      while (this.isRunning && !state.complete) {\n        try {\n          const {\n            transactions,\n            continuation\n          } = await this.provider.getTransactions({\n            address: this.params.address,\n            continuation: this.continuation\n          });\n          state.complete = !state.complete && transactions.length == null;\n\n          if (!this.isRunning || state.complete) {\n            break;\n          }\n\n          const fromFilteredTransactions = transactions.filter(item => (params.fromLt == null || item.id.lt > params.fromLt) && (params.fromUtime == null || item.createdAt > params.fromUtime));\n\n          if (fromFilteredTransactions.length == 0) {\n            state.complete = true;\n            break;\n          }\n\n          const toFilteredTransactions = fromFilteredTransactions.filter(item => (params.toLt == null || item.id.lt < params.toLt) && (params.toUtime == null || item.createdAt < params.toUtime));\n\n          if (toFilteredTransactions.length > 0) {\n            const info = {\n              maxLt: toFilteredTransactions[0].id.lt,\n              minLt: toFilteredTransactions[toFilteredTransactions.length - 1].id.lt,\n              batchType: 'old'\n            };\n            this.queue.enqueue(async () => {\n              const isRunning = this.params.onData({\n                address: this.params.address,\n                transactions: toFilteredTransactions,\n                info\n              });\n\n              if (!isRunning) {\n                state.complete = true;\n                this.isRunning = false;\n              }\n            });\n          }\n\n          if (continuation != null) {\n            this.continuation = continuation;\n          } else {\n            state.complete = true;\n            break;\n          }\n        } catch (e) {\n          console.error(e);\n        }\n      }\n\n      this.queue.enqueue(async () => this.params.onEnd(state.complete));\n      this.isRunning = false;\n      this.continuation = undefined;\n    })();\n  }\n\n  async stop() {\n    this.isRunning = false;\n    this.queue.clear();\n\n    if (this.promise != null) {\n      await this.promise;\n    } else {\n      this.params.onEnd(false);\n    }\n  }\n\n}\n\nclass TraceTransactionsScanner {\n  constructor(subscriber, params) {\n    this.subscriber = subscriber;\n    this.params = params;\n    this.queue = new PromiseQueue();\n    this.isRunning = false;\n    this.streams = new Map();\n    this.pendingTransactions = new Map();\n  }\n\n  start() {\n    if (this.isRunning || this.promise != null) {\n      return;\n    }\n\n    const subscriber = this.subscriber;\n    this.isRunning = true;\n\n    this.promise = (async () => {\n      const state = {\n        complete: false\n      };\n      const fromLt = this.params.origin.id.lt;\n\n      const startDstStreams = transaction => {\n        for (const message of transaction.outMessages) {\n          if (message.dst == null) {\n            continue;\n          }\n\n          const address = message.dst.toString();\n\n          if (this.streams.has(address)) {\n            continue;\n          }\n\n          const stream = subscriber.oldTransactions(message.dst, {\n            fromLt\n          }).merge(subscriber.transactions(message.dst)).flatMap(_ref2 => {\n            let {\n              address,\n              transactions\n            } = _ref2;\n            return transactions.map(transaction => {\n              transaction.account = address;\n              return transaction;\n            });\n          });\n          this.streams.set(address, stream);\n          stream.on(transaction => {\n            const messageHash = transaction.inMessage.hash;\n            const pendingTransaction = this.pendingTransactions.get(messageHash);\n\n            if (pendingTransaction == null) {\n              this.pendingTransactions.set(messageHash, {\n                promise: Promise.resolve(transaction),\n                resolve: () => {},\n                reject: () => {}\n              });\n            } else {\n              pendingTransaction.resolve(transaction);\n            }\n          });\n        }\n      };\n\n      const transactionsQueue = [this.params.origin];\n\n      try {\n        outer: while (this.isRunning) {\n          const transaction = transactionsQueue.shift();\n\n          if (transaction == null) {\n            state.complete = true;\n            break;\n          }\n\n          startDstStreams(transaction);\n\n          for (const message of transaction.outMessages) {\n            if (message.dst == null) {\n              continue;\n            }\n\n            const pendingTransaction = this.pendingTransactions.get(message.hash);\n            let transactionPromise;\n\n            if (pendingTransaction == null) {\n              let resolve;\n              let reject;\n              const promise = new Promise((promiseResolve, promiseReject) => {\n                resolve = tx => promiseResolve(tx);\n\n                reject = () => promiseReject();\n              });\n              this.pendingTransactions.set(message.hash, {\n                promise,\n                resolve: resolve,\n                reject: reject\n              });\n              transactionPromise = promise;\n            } else {\n              transactionPromise = pendingTransaction.promise;\n            }\n\n            const childTransaction = await transactionPromise;\n\n            if (!this.isRunning || state.complete) {\n              break outer;\n            }\n\n            this.queue.enqueue(async () => {\n              const isRunning = this.params.onData(childTransaction);\n\n              if (!isRunning) {\n                state.complete = true;\n                this.isRunning = false;\n                this.rejectPendingTransactions();\n              }\n            });\n            transactionsQueue.push(childTransaction);\n          }\n        }\n      } catch (e) {} finally {\n        this.queue.enqueue(async () => this.params.onEnd(state.complete));\n        this.isRunning = false;\n\n        for (const stream of this.streams.values()) {\n          stream.stopProducer();\n        }\n      }\n    })();\n  }\n\n  async stop() {\n    this.isRunning = false;\n    this.queue.clear();\n    this.rejectPendingTransactions();\n\n    if (this.promise != null) {\n      await this.promise;\n    } else {\n      this.params.onEnd(false);\n    }\n  }\n\n  rejectPendingTransactions() {\n    for (const pendingTransaction of this.pendingTransactions.values()) {\n      pendingTransaction.reject();\n    }\n  }\n\n}\n\nclass PromiseQueue {\n  constructor() {\n    this.queue = [];\n    this.workingOnPromise = false;\n  }\n\n  enqueue(promise) {\n    this.queue.push(promise);\n\n    this._dequeue().catch(() => {});\n  }\n\n  clear() {\n    this.queue.length = 0;\n  }\n\n  async _dequeue() {\n    if (this.workingOnPromise) {\n      return;\n    }\n\n    const item = this.queue.shift();\n\n    if (!item) {\n      return;\n    }\n\n    this.workingOnPromise = true;\n    item().then(() => {\n      this.workingOnPromise = false;\n\n      this._dequeue();\n    }).catch(() => {\n      this.workingOnPromise = false;\n\n      this._dequeue();\n    });\n  }\n\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Subscriber","utils_1","require","constructor","provider","subscriptions","scanners","unsubscribe","_unsubscribe","transactions","address","_addSubscription","trace","transaction","id","getUniqueId","StreamImpl","onData","onEnd","scanner","TraceTransactionsScanner","origin","eof","start","Promise","resolve","stop","identity","oldTransactions","filter","UnorderedTransactionsScanner","states","assign","keys","all","values","map","item","events","event","eventData","subscription","then","catch","concat","isFinite","rawAddress","toString","stopProducer","handler","handlers","queue","state","finished","clear","enqueue","length","console","debug","PromiseQueue","subscribe","on","data","forEach","e","error","makeProducer","extractor","fold","onlyFinite","init","f","ctx","reject","subscribed","Error","_item","undefined","delayed","result","first","found","_eof","merge","other","stopped","counter","checkEnd","enumerate","index","tap","filterMap","newItem","flatMap","items","skip","n","skipWhile","shouldSkip","take","takeWhile","takeWhileMap","params","isRunning","promise","complete","continuation","getTransactions","fromFilteredTransactions","fromLt","lt","fromUtime","createdAt","toFilteredTransactions","toLt","toUtime","info","maxLt","minLt","batchType","subscriber","streams","Map","pendingTransactions","startDstStreams","message","outMessages","dst","has","stream","account","set","messageHash","inMessage","hash","pendingTransaction","get","transactionsQueue","outer","shift","transactionPromise","promiseResolve","promiseReject","tx","childTransaction","rejectPendingTransactions","push","workingOnPromise","_dequeue"],"sources":["/Users/romanrakhlin/Dropbox/Mac/Desktop/cross-chain-reputation/client/node_modules/everscale-inpage-provider/dist/stream.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Subscriber = void 0;\nconst utils_1 = require(\"./utils\");\n/**\n * @category Stream\n */\nclass Subscriber {\n    constructor(provider) {\n        this.provider = provider;\n        this.subscriptions = {};\n        this.scanners = {};\n        this.unsubscribe = async () => this._unsubscribe();\n    }\n    /**\n     * Returns a stream of new transactions\n     */\n    transactions(address) {\n        return this._addSubscription('transactionsFound', address, false);\n    }\n    /**\n     * Returns a finite stream of child transactions\n     * @param transaction - root transaction\n     */\n    trace(transaction) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const scanner = new TraceTransactionsScanner(this, {\n                origin: transaction,\n                onData,\n                onEnd: (eof) => {\n                    delete this.scanners[id];\n                    onEnd(eof);\n                },\n            });\n            this.scanners[id] = scanner;\n            scanner.start();\n            // Subscription is not required\n            return Promise.resolve();\n        }, async () => {\n            const scanner = this.scanners[id];\n            delete this.scanners[id];\n            if (scanner != null) {\n                await scanner.stop();\n            }\n        }, identity, true);\n    }\n    /**\n     * Returns a stream of old transactions\n     */\n    oldTransactions(address, filter) {\n        const id = (0, utils_1.getUniqueId)();\n        return new StreamImpl((onData, onEnd) => {\n            const scanner = new UnorderedTransactionsScanner(this.provider, {\n                address,\n                onData,\n                onEnd: (eof) => {\n                    delete this.scanners[id];\n                    onEnd(eof);\n                },\n                ...filter,\n            });\n            this.scanners[id] = scanner;\n            scanner.start();\n            // Subscription is not required\n            return Promise.resolve();\n        }, async () => {\n            const scanner = this.scanners[id];\n            delete this.scanners[id];\n            if (scanner != null) {\n                await scanner.stop();\n            }\n        }, identity, true);\n    }\n    states(address) {\n        return this._addSubscription('contractStateChanged', address, false);\n    }\n    async _unsubscribe() {\n        const subscriptions = Object.assign({}, this.subscriptions);\n        for (const address of Object.keys(this.subscriptions)) {\n            delete this.subscriptions[address];\n        }\n        const scanners = Object.assign({}, this.scanners);\n        for (const id of Object.keys(this.scanners)) {\n            delete this.scanners[id];\n        }\n        await Promise.all(Object.values(subscriptions)\n            .map(async (item) => {\n            const events = Object.assign({}, item);\n            for (const event of Object.keys(events)) {\n                delete item[event];\n            }\n            await Promise.all(Object.values(events).map((eventData) => {\n                if (eventData == null) {\n                    return;\n                }\n                return eventData.subscription.then((item) => {\n                    return item.unsubscribe();\n                }).catch(() => {\n                    // ignore\n                });\n            }));\n        }).concat(Object.values(scanners).map((item) => item.stop())));\n    }\n    _addSubscription(event, address, isFinite) {\n        const rawAddress = address.toString();\n        const stopProducer = (id) => {\n            const subscriptions = this.subscriptions[rawAddress];\n            if (subscriptions == null) {\n                // No subscriptions for the address\n                return;\n            }\n            const eventData = subscriptions[event];\n            if (eventData != null) {\n                const handler = eventData.handlers[id];\n                if (handler != null) {\n                    // Remove event handler with the id\n                    delete eventData.handlers[id];\n                    const { queue, onEnd, state } = handler;\n                    if (!state.finished) {\n                        state.finished = true;\n                        queue.clear();\n                        queue.enqueue(async () => onEnd(state.eof));\n                    }\n                }\n                // Remove event data subscription if there are none of them\n                if (Object.keys(eventData.handlers).length === 0) {\n                    const subscription = eventData.subscription;\n                    delete subscriptions[event];\n                    subscription\n                        .then((subscription) => subscription.unsubscribe())\n                        .catch(console.debug);\n                }\n            }\n            // Remove address subscriptions object if it is empty\n            if (Object.keys(subscriptions).length === 0) {\n                delete this.subscriptions[rawAddress];\n            }\n        };\n        const id = (0, utils_1.getUniqueId)().toString();\n        return new StreamImpl((onData, onEnd) => {\n            let subscriptions = this.subscriptions[rawAddress];\n            let eventData = subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions[event];\n            const state = { eof: false, finished: false };\n            // Create handler object\n            const handler = {\n                onData,\n                onEnd,\n                queue: new PromiseQueue(),\n                state,\n            };\n            if (eventData != null) {\n                // Add handler if there is already a handler group\n                eventData.handlers[id] = handler;\n                return Promise.resolve();\n            }\n            // Create handlers group\n            const handlers = {\n                [id]: handler,\n            };\n            // Create subscription\n            const subscription = this.provider.subscribe(event, { address })\n                .then((subscription) => {\n                subscription.on('data', (data) => {\n                    Object.values(handlers).forEach(({ onData, queue, state }) => {\n                        // Skip closed streams\n                        if (state.eof || state.finished) {\n                            return;\n                        }\n                        queue.enqueue(async () => {\n                            if (!(await onData(data))) {\n                                state.eof = true;\n                                stopProducer(id);\n                            }\n                        });\n                    });\n                });\n                subscription.on('unsubscribed', () => {\n                    Object.keys(handlers).forEach(stopProducer);\n                });\n                return subscription;\n            }).catch((e) => {\n                console.error(e);\n                Object.keys(handlers).forEach(stopProducer);\n                throw e;\n            });\n            // Add event data to subscriptions\n            eventData = { subscription, handlers };\n            if (subscriptions == null) {\n                this.subscriptions[rawAddress] = { [event]: eventData };\n            }\n            else {\n                subscriptions[event] = eventData;\n            }\n            // Wait until subscribed\n            return subscription.then(() => {\n            });\n        }, () => stopProducer(id), identity, isFinite);\n    }\n}\nexports.Subscriber = Subscriber;\nasync function identity(item, handler) {\n    return handler(item);\n}\nclass StreamImpl {\n    constructor(makeProducer, stopProducer, extractor, isFinite) {\n        this.makeProducer = makeProducer;\n        this.stopProducer = stopProducer;\n        this.extractor = extractor;\n        this.isFinite = isFinite;\n        /**\n         * Folds every element into an accumulator by applying an operation, returning the final result\n         */\n        this.fold = this.onlyFinite((init, f, ctx) => {\n            let state = init;\n            return new Promise((resolve, reject) => {\n                const subscribed = this.makeProducer(\n                // onData\n                (data) => this.extractor(data, async (item) => {\n                    state = await f(state, item);\n                    return true;\n                }), \n                // onEnd\n                (eof) => {\n                    if (eof) {\n                        resolve(state);\n                    }\n                    else {\n                        reject(new Error('Subscription closed'));\n                    }\n                });\n                if (ctx != null) {\n                    ctx.subscribed = subscribed;\n                }\n            });\n        });\n        /**\n         * Waits until the end of the stream\n         */\n        this.finished = this.onlyFinite((ctx) => {\n            return new Promise((resolve, reject) => {\n                const subscribed = this.makeProducer(\n                // onData\n                (data) => this.extractor(data, (_item) => true), \n                // onEnd\n                (eof) => {\n                    if (eof) {\n                        resolve(undefined);\n                    }\n                    else {\n                        reject(new Error('Subscription closed'));\n                    }\n                });\n                if (ctx != null) {\n                    ctx.subscribed = subscribed;\n                }\n            });\n        });\n    }\n    async delayed(f) {\n        const { subscribed, result } = f({\n            first: (() => {\n                const ctx = {};\n                const result = this.first(ctx);\n                return { subscribed: ctx.subscribed, result };\n            }),\n            on: (handler) => {\n                const ctx = {};\n                this.on(handler, ctx);\n                return { subscribed: ctx.subscribed, result: undefined };\n            },\n            fold: this.fold != null ? (init, f) => {\n                const ctx = {};\n                const result = this.fold(init, f, ctx);\n                return { subscribed: ctx.subscribed, result };\n            } : undefined,\n            finished: this.finished != null ? () => {\n                const ctx = {};\n                const result = this.finished(ctx);\n                return { subscribed: ctx.subscribed, result };\n            } : undefined,\n        });\n        await subscribed;\n        return () => result;\n    }\n    first(ctx) {\n        let state = { found: false };\n        return new Promise((resolve, reject) => {\n            const subscribed = this.makeProducer(\n            // onData\n            (data) => this.extractor(data, (item) => {\n                Object.assign(state, { found: true, result: item });\n                return false;\n            }), \n            // onEnd\n            (eof) => {\n                if (eof) {\n                    if (this.isFinite) {\n                        resolve((state.found ? state.result : undefined));\n                    }\n                    else if (state.found) {\n                        resolve(state.result);\n                    }\n                    else {\n                        reject(new Error('Unexpected end of stream'));\n                    }\n                }\n                else {\n                    reject(new Error('Subscription closed'));\n                }\n            });\n            if (ctx != null) {\n                ctx.subscribed = subscribed;\n            }\n        });\n    }\n    on(handler, ctx) {\n        const subscribed = this.makeProducer((event) => this.extractor(event, async (item) => {\n            await handler(item);\n            return true;\n        }), (_eof) => {\n        });\n        if (ctx != null) {\n            ctx.subscribed = subscribed;\n        }\n    }\n    merge(other) {\n        return new StreamImpl((onData, onEnd) => {\n            const state = {\n                stopped: false,\n                counter: 0,\n            };\n            const checkEnd = (eof) => {\n                if (state.stopped) {\n                    return;\n                }\n                if (++state.counter == 2 || !eof) {\n                    state.stopped = true;\n                    onEnd(eof);\n                }\n            };\n            return Promise.all([\n                this.makeProducer(onData, checkEnd),\n                other.makeProducer(onData, checkEnd),\n            ]).then(() => {\n            });\n        }, () => {\n            this.stopProducer();\n            other.stopProducer();\n        }, this.extractor, (this.isFinite && other.isFinite));\n    }\n    enumerate() {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            return handler({\n                index: state.index++,\n                item,\n            });\n        }), this.isFinite);\n    }\n    tap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            await f(item);\n            return handler(item);\n        }), this.isFinite);\n    }\n    filter(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (await f(item)) {\n                return handler(item);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    filterMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            if (newItem !== undefined) {\n                return handler(newItem);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    map(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            return handler(newItem);\n        }), this.isFinite);\n    }\n    flatMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const items = await f(item);\n            for (const newItem of items) {\n                if (!(await handler(newItem))) {\n                    return false;\n                }\n            }\n            return true;\n        }), this.isFinite);\n    }\n    skip(n) {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, (item) => {\n            if (state.index >= n) {\n                return handler(item);\n            }\n            else {\n                ++state.index;\n                return true;\n            }\n        }), this.isFinite);\n    }\n    skipWhile(f) {\n        const state = {\n            shouldSkip: true,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (!state.shouldSkip || !(await f(item))) {\n                state.shouldSkip = false;\n                return handler(item);\n            }\n            else {\n                return true;\n            }\n        }), this.isFinite);\n    }\n    take(n) {\n        const state = {\n            index: 0,\n        };\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, (item) => {\n            if (state.index < n) {\n                ++state.index;\n                return handler(item);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    takeWhile(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            if (await f(item)) {\n                return handler(item);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    takeWhileMap(f) {\n        return new StreamImpl(this.makeProducer, this.stopProducer, (event, handler) => this.extractor(event, async (item) => {\n            const newItem = await f(item);\n            if (newItem !== undefined) {\n                return handler(newItem);\n            }\n            else {\n                return false;\n            }\n        }), true);\n    }\n    onlyFinite(f) {\n        if (this.isFinite) {\n            return f;\n        }\n        else {\n            return undefined;\n        }\n    }\n}\nclass UnorderedTransactionsScanner {\n    constructor(provider, params) {\n        this.provider = provider;\n        this.params = params;\n        this.queue = new PromiseQueue();\n        this.isRunning = false;\n    }\n    start() {\n        if (this.isRunning || this.promise != null) {\n            return;\n        }\n        this.isRunning = true;\n        this.promise = (async () => {\n            const params = this.params;\n            let state = {\n                complete: false,\n            };\n            while (this.isRunning && !state.complete) {\n                try {\n                    const { transactions, continuation } = await this.provider.getTransactions({\n                        address: this.params.address,\n                        continuation: this.continuation,\n                    });\n                    state.complete = !state.complete && transactions.length == null;\n                    if (!this.isRunning || state.complete) {\n                        break;\n                    }\n                    const fromFilteredTransactions = transactions.filter((item) => ((params.fromLt == null || item.id.lt > params.fromLt) &&\n                        (params.fromUtime == null || item.createdAt > params.fromUtime)));\n                    if (fromFilteredTransactions.length == 0) {\n                        state.complete = true;\n                        break;\n                    }\n                    const toFilteredTransactions = fromFilteredTransactions.filter((item) => ((params.toLt == null || item.id.lt < params.toLt) &&\n                        (params.toUtime == null || item.createdAt < params.toUtime)));\n                    if (toFilteredTransactions.length > 0) {\n                        const info = {\n                            maxLt: toFilteredTransactions[0].id.lt,\n                            minLt: toFilteredTransactions[toFilteredTransactions.length - 1].id.lt,\n                            batchType: 'old',\n                        };\n                        this.queue.enqueue(async () => {\n                            const isRunning = this.params.onData({\n                                address: this.params.address,\n                                transactions: toFilteredTransactions,\n                                info,\n                            });\n                            if (!isRunning) {\n                                state.complete = true;\n                                this.isRunning = false;\n                            }\n                        });\n                    }\n                    if (continuation != null) {\n                        this.continuation = continuation;\n                    }\n                    else {\n                        state.complete = true;\n                        break;\n                    }\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            }\n            this.queue.enqueue(async () => this.params.onEnd(state.complete));\n            this.isRunning = false;\n            this.continuation = undefined;\n        })();\n    }\n    async stop() {\n        this.isRunning = false;\n        this.queue.clear();\n        if (this.promise != null) {\n            await this.promise;\n        }\n        else {\n            this.params.onEnd(false);\n        }\n    }\n}\nclass TraceTransactionsScanner {\n    constructor(subscriber, params) {\n        this.subscriber = subscriber;\n        this.params = params;\n        this.queue = new PromiseQueue();\n        this.isRunning = false;\n        this.streams = new Map();\n        this.pendingTransactions = new Map();\n    }\n    start() {\n        if (this.isRunning || this.promise != null) {\n            return;\n        }\n        const subscriber = this.subscriber;\n        this.isRunning = true;\n        this.promise = (async () => {\n            const state = {\n                complete: false,\n            };\n            const fromLt = this.params.origin.id.lt;\n            const startDstStreams = (transaction) => {\n                for (const message of transaction.outMessages) {\n                    if (message.dst == null) {\n                        continue;\n                    }\n                    const address = message.dst.toString();\n                    if (this.streams.has(address)) {\n                        continue;\n                    }\n                    const stream = subscriber.oldTransactions(message.dst, { fromLt })\n                        .merge(subscriber.transactions(message.dst))\n                        .flatMap(({ address, transactions }) => transactions.map(transaction => {\n                        transaction.account = address;\n                        return transaction;\n                    }));\n                    this.streams.set(address, stream);\n                    stream.on((transaction) => {\n                        const messageHash = transaction.inMessage.hash;\n                        const pendingTransaction = this.pendingTransactions.get(messageHash);\n                        if (pendingTransaction == null) {\n                            this.pendingTransactions.set(messageHash, {\n                                promise: Promise.resolve(transaction),\n                                resolve: () => {\n                                },\n                                reject: () => {\n                                },\n                            });\n                        }\n                        else {\n                            pendingTransaction.resolve(transaction);\n                        }\n                    });\n                }\n            };\n            const transactionsQueue = [this.params.origin];\n            try {\n                outer: while (this.isRunning) {\n                    const transaction = transactionsQueue.shift();\n                    if (transaction == null) {\n                        state.complete = true;\n                        break;\n                    }\n                    startDstStreams(transaction);\n                    for (const message of transaction.outMessages) {\n                        if (message.dst == null) {\n                            continue;\n                        }\n                        const pendingTransaction = this.pendingTransactions.get(message.hash);\n                        let transactionPromise;\n                        if (pendingTransaction == null) {\n                            let resolve;\n                            let reject;\n                            const promise = new Promise((promiseResolve, promiseReject) => {\n                                resolve = (tx) => promiseResolve(tx);\n                                reject = () => promiseReject();\n                            });\n                            this.pendingTransactions.set(message.hash, {\n                                promise,\n                                resolve: resolve,\n                                reject: reject,\n                            });\n                            transactionPromise = promise;\n                        }\n                        else {\n                            transactionPromise = pendingTransaction.promise;\n                        }\n                        const childTransaction = await transactionPromise;\n                        if (!this.isRunning || state.complete) {\n                            break outer;\n                        }\n                        this.queue.enqueue(async () => {\n                            const isRunning = this.params.onData(childTransaction);\n                            if (!isRunning) {\n                                state.complete = true;\n                                this.isRunning = false;\n                                this.rejectPendingTransactions();\n                            }\n                        });\n                        transactionsQueue.push(childTransaction);\n                    }\n                }\n            }\n            catch (e) {\n            }\n            finally {\n                this.queue.enqueue(async () => this.params.onEnd(state.complete));\n                this.isRunning = false;\n                for (const stream of this.streams.values()) {\n                    stream.stopProducer();\n                }\n            }\n        })();\n    }\n    async stop() {\n        this.isRunning = false;\n        this.queue.clear();\n        this.rejectPendingTransactions();\n        if (this.promise != null) {\n            await this.promise;\n        }\n        else {\n            this.params.onEnd(false);\n        }\n    }\n    rejectPendingTransactions() {\n        for (const pendingTransaction of this.pendingTransactions.values()) {\n            pendingTransaction.reject();\n        }\n    }\n}\nclass PromiseQueue {\n    constructor() {\n        this.queue = [];\n        this.workingOnPromise = false;\n    }\n    enqueue(promise) {\n        this.queue.push(promise);\n        this._dequeue().catch(() => {\n        });\n    }\n    clear() {\n        this.queue.length = 0;\n    }\n    async _dequeue() {\n        if (this.workingOnPromise) {\n            return;\n        }\n        const item = this.queue.shift();\n        if (!item) {\n            return;\n        }\n        this.workingOnPromise = true;\n        item()\n            .then(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        })\n            .catch(() => {\n            this.workingOnPromise = false;\n            this._dequeue();\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}